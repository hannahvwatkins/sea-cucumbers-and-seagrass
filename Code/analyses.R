#This script is for the analysis of sea cucumbers and seagrass in Watkins et 
#al., 2023 in Ecosphere

#Please note that Stan models can only be reproduced identically when run on the 
#same machine because the Markov Chain Monte Carlo sampler has a random
#component, so even when setting the seed, there will be slight variations in 
#the iterations between machines (this tends to result in super tiny differences 
#in the posteriors though, so does not change interpretation of the models).
#For consistency and to make it possible to review our results, we have run each
#model using random seeds generated by R and saved each model output. These are
#found in the Data folder and can be run directly using the code provided.

library(tidyverse) #for general data processing
library(brms) #for running models
library(rstan) #for setting up options for the underlying Stan models in brms
library(bayestestR) #for estimating probability of direction
library(loo) #for comparing models
library(DHARMa) #for checking residuals
options(mc.cores = parallel::detectCores())#for greater model running efficiency
rstan_options(auto_write = TRUE)

#LOAD IN DATA-------------------------------------------------------------------
#initial values
init <- read_csv("Data/main_sampling_clean.csv") %>% 
  #select only data from the initial time point
  filter(sampling_period == 0) %>% 
  #set the control treatment as the baseline level
  mutate(treatment = factor(treatment, 
                            levels = c("natural", "half", "zero"))) %>% 
  #for the PCA we only want data where there is no missing info in our responses
  drop_na(shoot_count, mean_blade_height, above_ground, below_ground, 
          percent_total_n) %>% 
  #and because the initial models don't have a log link, we're going to 
  #log-transform and scale distance to allow for an exponential decay of 
  #seagrass as you move away fromthe reef - need to add a tiny value (i.e., half 
  #of the minimum non-zero value) to distance because there are some zeros
  mutate(log_distance = log(distance_patch+0.05),
         scale_log_distance = scale(log_distance))

#initial values with all unique blade heights
init_all_heights <- read_csv("Data/main_sampling_clean_with_heights.csv") %>% 
  #select only data from the initial time point
  filter(sampling_period == 0) %>% 
  #set the control treatment as the baseline level
  mutate(treatment = factor(treatment, 
                            levels = c("natural", "half", "zero")))

#full sampling data
props <- read_csv("Data/sampling_data_averaged_proportions.csv") %>% 
  #set the control treatment as the baseline level
  mutate(treatment = factor(treatment, 
                            levels = c("natural", "half", "zero"))) %>% 
  #remove all rows with NAs for pca to work
  filter_at(vars(mean_shoot_prop, mean_height_prop, mean_above_prop, 
                 mean_below_prop, mean_percent_total_n_prop),
            all_vars(!is.na(.))) %>% 
  #remove the three outliers  that are most likely a mistake based on the
  #shoot count/height comparison to above and belowground - see paper for 
  #an explanation of outlier removal
  filter(patch != "Vancouver" | (patch == "Vancouver" & quadrat != 3)) %>% 
  filter(patch != 'Montreal' | (patch == "Montreal" & quadrat != 1)) %>% 
  filter(patch != '78S' | (patch == '78S' & quadrat != 1)) %>% 
  #log transform distance from reef
  mutate(log_distance = log(mean_distance+0.05),
         scale_log_distance = scale(log_distance))

#change in nitrogen composition data
props_n <- read_csv("Data/sampling_data_averaged_proportions.csv") %>% 
  #set the control treatment as the baseline level
  mutate(treatment = factor(treatment, 
                            levels = c("natural", "half", "zero")),
         scale_n_offset = scale(mean_total_n_offset)) %>%
  #remove the middle sampling period for which we don't have data
  filter(sampling_period != 1)

#responses from sampling data to combine with the growth data
below <- read_csv("Data/sampling_data_averaged_proportions.csv") %>% 
  select(patch, quadrat, mean_shoot_count_offset:mean_total_n_offset) %>% 
  distinct() %>% 
  #standardize the belowground biomass for each distance from patch to use as 
  #a predictor in the growth model
  mutate(scale_mean_below_offset = scale(mean_below_offset))

#growth experiment data
growths <- read_csv("Data/seagrass_growth_clean.csv") %>% 
  #connect to the relevant belowground biomass data
  left_join(below, by = c("patch", "quadrat")) %>% 
  #calculate the belowground biomass per shoot and standardize it
  mutate(below_per_shoot = mean_below_offset/shoots_found,
         scale_below_per_shoot = scale(below_per_shoot)) %>% 
  #create a unique name for each quadrat since we're going to use this in our
  #random effects structure
  unite(quad_id, c(patch,quadrat), remove = FALSE)

#PART ONE: INITIAL SAMPLING----------------------------------------------------
#first we'll examine the correlation between our response variables
responses <- init %>% 
  select(shoot_count, mean_blade_height, above_ground, below_ground,
         percent_total_n)
cor(responses)
#can get p-values for this matrix with the "HMisc" package:
Hmisc::rcorr(as.matrix(responses))
#the four measures of quantity all have relatively high correlations with one
#another, while the nitrogen composition is only slightly negatively correlated
#with them

#for our PCA, we'll just grab the quantitative metrics
init_resp <- init %>% 
  select(shoot_count, mean_blade_height, above_ground, below_ground)

#let's condense these variables into principal components
pca_values <- prcomp(init_resp, center = TRUE, scale = TRUE)
summary(pca_values) 

#turn the points into a df
pca_points <- 
  # first convert the pca results to a tibble
  as_tibble(pca_values$x) %>% 
  # now we'll add the full data
  bind_cols(init)

#now let's make a model to see what's associated with higher seagrass quantities
#set up some very basic regularizing priors
init_priors <- prior_string("normal(0,1)", class = "b")
#and run the model
mod_init <- brm(PC1 ~ scale_log_og_cukes *
                  scale_log_grunt_pee_m2 +
                  scale_log_distance +
                  scale_sand +
                  scale_seagrass_area + 
                  (1|patch), 
                  prior = init_priors,
                  iter = 3000,
                data = pca_points)
#saveRDS(mod_init, "Data/initial_PC1_mod.rds")
mod_init <- readRDS("Data/initial_PC1_mod.rds")
summary(mod_init)
#calculate probabilities of direction
pd(mod_init)
#check traceplots
plot(mod_init)
#looking great

#and posterior predictive distributions
pp_check(mod_init)
#looking great

#and use DHARMa to examine residuals
#note that NAs are automatically removed from the brms model but we also have
#to remove them from the dataset to make this function work
pca_points_noNA <- pca_points %>% 
  filter(!is.na(scale_sand))
mod_check_init <- createDHARMa(
  simulatedResponse = t(posterior_predict(mod_init)),
  observedResponse = pca_points_noNA$PC1,
  fittedPredictedResponse = apply(t(posterior_epred(mod_init)), 1, mean),
  integerResponse = TRUE)
plot(mod_check_init)
#looks great

#now examine seagrass quality
#first need to take only one value per quadrat since the N samples were 
#combined for each distance from patch (e.g., all Q1s combined, etc.)
init_n <- init %>% 
  group_by(patch, quadrat) %>% 
  summarise(scale_log_og_cukes = first(scale_log_og_cukes), 
            scale_log_grunt_pee_m2 = first(scale_log_grunt_pee_m2),
            scale_distance = mean(scale_distance),
            scale_sand = mean(scale_sand),
            scale_seagrass_area = first(scale_seagrass_area),
            percent_total_n = first(percent_total_n),
            scale_log_distance = first(scale_log_distance)) %>% 
  ungroup() %>% 
  #convert proportions to percent because of issues with the units being too
  #tiny 
  #even though these values are technically constrained by 0 and 1, which would
  #normally suggest we need to use a Beta distribution, they fall into such 
  #a tiny range that it's almost impossible to estimate the shape parameter
  #(it falls into the range of 1000s, which is kind of nonsensical)
  #since the upper and lower edges of the data are nowhere near the bounds, it
  #is reasonable to model as a continuous distribution instead
  mutate(percent_total_n_100 = percent_total_n * 100)

#weakly regularizing priors
init_priors_n <- prior_string("normal(0,1)", class = "b")
mod_init_n <- brm(percent_total_n_100 ~ scale_log_og_cukes * 
                  scale_log_grunt_pee_m2 +
                  scale_log_distance +
                  scale_sand +
                  scale_seagrass_area + 
                  (1|patch), 
                family = skew_normal(), 
                #skew is a better fit than normal based on the residuals
                prior = init_priors_n,
                control = list(adapt_delta = 0.97),
                iter = 3000,
                data = init_n)
#saveRDS(mod_init_n, "Data/initial_nitrogen_mod.rds")
mod_init_n <- readRDS("Data/initial_nitrogen_mod.rds")
summary(mod_init_n)
pd(mod_init_n)
#do all of the same model checks as above
brms::pp_check(mod_init_n)
init_n_noNA <- init_n %>% 
  filter(!is.na(scale_sand)) %>% 
  filter(!is.na(percent_total_n))
mod_check_init_n <- createDHARMa(
  simulatedResponse = t(posterior_predict(mod_init_n)),
  observedResponse = init_n_noNA$percent_total_n_100,
  fittedPredictedResponse = apply(t(posterior_epred(mod_init_n)), 1, mean),
  integerResponse = TRUE)
plot(mod_check_init_n)
#looks fine

#extract mean PC1 value for each distance from patch (i.e., Q1 across all
#transects, Q2, Q3) for use in the second model
pc1_values <- pca_points %>% 
  select(patch, transect, quadrat, PC1) %>% 
  group_by(patch, quadrat) %>% 
  summarize(mean_PC1 = mean(PC1)) %>% 
  ungroup() %>% 
  mutate(scale_mean_PC1 = scale(mean_PC1))
  

#PART TWO A: POST-MANIPULATION SAMPLING QUANTITY-----------------------------
#let's condense these variables into principal components
prop_resp <- props %>% 
  select(mean_shoot_prop, mean_height_prop, mean_above_prop, mean_below_prop)
pca_values2 <- prcomp(prop_resp, center = TRUE, scale = TRUE)
summary(pca_values2) 

#turn the points into a df
pca_points2 <- 
  # first convert the pca results to a tibble
  as_tibble(pca_values2$x) %>% 
  # now we'll add the full data
  bind_cols(props) %>% 
  #and now we'll extract the PC1 values from the initial model to use as a 
  #predictor - note that while the way PC1 is calculated in part one and part
  #two is slightly different because the PCA is being fed different data, so
  # we can't make direct comparisons between individual values
  #but we can use the initial PC1s as our indicator of "initial quantity"
  left_join(pc1_values, by = c("patch", "quadrat")) 

#set regularizing priors
main_priors <- prior_string("normal(0,1)", class = "b")
mod_main_density <- brm(PC1 ~ scale_log_cukes_final * 
                  scale_log_grunt_pee_m2 +
                  scale_log_distance +
                  scale_seagrass_area + 
                  scale_mean_PC1 +
                  (1|patch), 
                  control = list(adapt_delta = 0.9), 
                  prior = main_priors,
                  iter = 3000,
                data = pca_points2)
#saveRDS(mod_main_density, "Data/main_model_density.rds")
mod_main_density <- readRDS("Data/main_model_density.rds")
summary(mod_main_density)
pd(mod_main_density)

#check posteriors
brms::pp_check(mod_main_density)
#and residuals
mod_check_density <- createDHARMa(
  simulatedResponse = t(posterior_predict(mod_main_density)),
  observedResponse = pca_points2$PC1,
  fittedPredictedResponse = apply(t(posterior_epred(mod_main_density)), 1, mean),
  integerResponse = TRUE)
plot(mod_check_density)

mod_main_treatment <- brm(PC1 ~ scale_cont_treatment * 
                          scale_log_grunt_pee_m2 +
                          scale_log_distance +
                          scale_seagrass_area + 
                          scale_mean_PC1 +
                          (1|patch), 
                        control = list(adapt_delta = 0.9),
                        prior = main_priors,
                        iter = 3000,
                        data = pca_points2)
#saveRDS(mod_main_treatment, "Data/main_model_treatment.rds")
mod_main_treatment <- readRDS("Data/main_model_treatment.rds")
summary(mod_main_treatment)
pd(mod_main_treatment)
#check fit
brms::pp_check(mod_main_treatment)
#and residuals
mod_check_treatment <- createDHARMa(
  simulatedResponse = t(posterior_predict(mod_main_treatment)),
  observedResponse = pca_points2$PC1,
  fittedPredictedResponse = apply(t(posterior_epred(mod_main_treatment)), 
                                  1, mean),
  integerResponse = TRUE)
plot(mod_check_treatment)

#compare the two models with elpd/looic
compare_mod_density <- add_criterion(mod_main_density, criterion = "loo")
compare_mod_treatment <- add_criterion(mod_main_treatment, criterion = "loo")
print(loo_compare(compare_mod_density, compare_mod_treatment, 
                  criterion = "loo"), 
      simplify = FALSE)

#PART TWO B: POST-MANIPULATION SAMPLING QUALITY-----------------------------
#first we need to look at the absolute differences between the pre and post
#samples to make sure the changes are large enough to not be attributable to
#measurement error alone
diffs <- props_n %>% 
  #convert from proportions to percents just to make it easier to keep track
  mutate(n_diff = mean_total_n_offset*100 - mean_total_n*100,
         within = case_when(n_diff <= 0.1 & n_diff >= -0.1 ~ "y",
                            TRUE ~ "n")) %>% 
  #then see how many fall within the range of measurement error of the machine,
  #which is 0.1% (or 0.001 in the proportion)
  group_by(within) %>% 
  summarize(n = n()) 
#and 44 out of 63 samples fall within the range of measurement error :( 
#any models we run on this won't be particularly meaningful and could lead to
#spurious correlations, so we shouldn't run them.
#womp womp.

#PART THREE: GROWTH RATES------------------------------------------------------
#make regularizing priors for all predictors
growth_priors <- prior_string("normal(0,1)", class = "b")
#build model
mod_growth <- brm(blade_height ~ scale_distance + 
                    scale_log_grunt_pee_m2  *
                    scale_log_cuke_density_final +
                    scale_below_per_shoot +
                    scale_seagrass_area +
                    (1|patch/quadrat), 
                  family = Gamma(link = "log"),
                  data = growths,
                  iter = 3000,
                  #priors to provide slight regularization
                  prior = growth_priors,
                  #increase adapt delta to prevent divergent transitions
                  control = list(adapt_delta = 0.97))
#saveRDS(mod_growth, "Data/final_growth_rate_model.rds")
mod_growth <- readRDS("Data/final_growth_rate_model.rds")
summary(mod_growth)
#check probability of direction (i.e., amount of posterior on one side of 0)
pd(mod_growth)

#model checks
#pp_check provides a quick way to diagnose major issues by comparing the
#distribution of our data to the model fit
brms::pp_check(mod_growth)
#the model appears to be a good fit

#and we can check the residuals with DHAMRa
growth_resids <- createDHARMa(
  simulatedResponse = t(posterior_predict(mod_growth)),
  observedResponse = growths$blade_height,
  fittedPredictedResponse = apply(t(posterior_epred(mod_growth)), 1, median),
  integerResponse = TRUE)
plot(growth_resids)
#not perfect, but very reasonable for the sample size (note that DHARMa uses 
#significance testing so is extremely sensitive to sample size!)
#there is a very tiny amount of underdispersion in the residuals, but this 
#simply reduces the power of the analysis (i.e., makes the credible intervals 
#wider than they should be). Since this issue does not bias the effects, nor 
#does it increase Type I error, it's a conservative choice to keep it as is!
#to double check that there's nothing worrisome going on here, we can look 
#at the raw predicted and observed values
plot(growth_resids$fittedPredictedResponse,growth_resids$observedResponse)
abline(a=0,b=1)
plot(growth_resids$fittedPredictedResponse,growth_resids$scaledResiduals)
#these look great. Across the full range of predicted values, there is an even 
#spread of observations above and below the line.

#we can also just quickly check to make sure that there isn't too much 
#collinearity between the predictors with the car package
#to do so, we need to create a basic lm() with the same predictors but no 
#random effects, interactions, or non-normal distributions
col_check <- lm(blade_height ~ scale_distance + 
                         scale_log_grunt_pee_m2  +
                         scale_log_cuke_density_final +
                         scale_below_per_shoot +
                         scale_seagrass_area, data = growths)
car::vif(col_check)
#and they're all under two which is great!

#PART ONE SUPPLEMENTAL: INDIVIDUAL RESPONSES----------------
#blade heights
init_priors <- prior_string("normal(0,1)", class = "b")
#heights are in quadrats nested in patches, unlike the rest of the models
#where quadrat is the unit of measurement
mod_init_height <- brm(height_cm ~ scale_log_og_cukes * 
                         scale_log_grunt_pee_m2 +
                         scale_distance + #not logged, since using a log link
                         scale_sand +
                         scale_seagrass_area + 
                         (1|patch/quadrat), 
                       data = init_all_heights, 
                       family = Gamma(link = "log"),
                       seed = 123,
                       control = list(adapt_delta = 0.9),
                       prior = init_priors)
#saveRDS(mod_init_height, "Data/initial_model_blade_heights.rds")
mod_init_height <- readRDS("Data/initial_model_blade_heights.rds")
summary(mod_init_height)
pd(mod_init_height)
#check fit
heights_noNA <- init_all_heights %>% 
  filter(!is.na(scale_sand)) %>% 
  filter(!is.na(height_cm))
mod_check_height <- createDHARMa(
  simulatedResponse = t(posterior_predict(mod_init_height)),
  observedResponse = heights_noNA$height_cm,
  fittedPredictedResponse = apply(t(posterior_epred(mod_init_height)), 1, mean),
  integerResponse = TRUE)
plot(mod_check_height)

mod_init_shoots <- brm(shoot_count ~ scale_log_og_cukes * 
                         scale_log_grunt_pee_m2 +
                         scale_distance +
                         scale_sand +
                         scale_seagrass_area + 
                         (1|patch), 
                       data = init,
                       family = negbinomial(link = "log"),
                       seed = 1234,
                       prior = init_priors)
#saveRDS(mod_init_shoots, "Data/initial_model_shoot_counts.rds")
mod_init_shoots <- readRDS("Data/initial_model_shoot_counts.rds")
summary(mod_init_shoots)
pd(mod_init_shoots)
#check fit
init_noNA <- init %>% 
  filter(!is.na(scale_sand)) 
mod_check_shoot <- createDHARMa(
  simulatedResponse = t(posterior_predict(mod_init_shoots)),
  observedResponse = init_noNA$shoot_count,
  fittedPredictedResponse = apply(t(posterior_epred(mod_init_shoots)), 1, mean),
  integerResponse = TRUE)
plot(mod_check_shoot)

#aboveground biomass
mod_init_above <- brm(above_ground ~ scale_log_og_cukes * 
                        scale_log_grunt_pee_m2 +
                        scale_distance +
                        scale_sand +
                        scale_seagrass_area + 
                        (1|patch), 
                      data = init,
                      family = Gamma(link = "log"),
                      seed = 123,
                      prior = init_priors)
#saveRDS(mod_init_above, "Data/initial_model_aboveground_biomass.rds")
mod_init_above <- readRDS("Data/initial_model_aboveground_biomass.rds")
summary(mod_init_above)
pd(mod_init_above)
#check fit
mod_check_above <- createDHARMa(
  simulatedResponse = t(posterior_predict(mod_init_above)),
  observedResponse = init_noNA$above_ground,
  fittedPredictedResponse = apply(t(posterior_epred(mod_init_above)), 1, mean),
  integerResponse = TRUE)
plot(mod_check_above)

#belowground biomass
mod_init_below <- brm(below_ground ~ scale_log_og_cukes * 
                        scale_log_grunt_pee_m2 +
                        scale_distance +
                        scale_sand +
                        scale_seagrass_area + 
                        (1|patch), 
                      data = init,
                      family = Gamma(link = "log"),
                      seed = 123,
                      prior = init_priors)
#saveRDS(mod_init_below, "Data/initial_model_belowground_biomass.rds")
mod_init_below <- readRDS("Data/initial_model_belowground_biomass.rds")
summary(mod_init_below)
pd(mod_init_below)
#check fit
mod_check_below <- createDHARMa(
  simulatedResponse = t(posterior_predict(mod_init_below)),
  observedResponse = init_noNA$below_ground,
  fittedPredictedResponse = apply(t(posterior_epred(mod_init_below)), 1, mean),
  integerResponse = TRUE)
plot(mod_check_below)


#PART TWO SUPPLEMENTAL: INDIVIDUAL REPSONSES---------------
#scale initial values used as predictors
props <- props %>% 
  mutate(scale_height_offset = scale(mean_height_offset),
         scale_shoot_offset = scale(mean_shoot_count_offset),
         scale_above_offset = scale(mean_above_offset),
         scale_below_offset = scale(mean_below_offset))

#blade heights
main_priors <- prior_string("normal(0,1)", class = "b")
mod_height_density <- brm(mean_height_prop ~ scale_log_cukes_final * 
                            scale_log_grunt_pee_m2 +
                            scale_distance +
                            scale_seagrass_area + 
                            scale_height_offset +
                            (1|patch), 
                          seed = 123,
                          control = list(adapt_delta = 0.9), 
                          family = Gamma(link = 'log'),
                          prior = main_priors,
                          data = props)

#saveRDS(mod_height_density, "Data/main_model_height_density.rds")
mod_height_density <- readRDS("Data/main_model_height_density.rds")
summary(mod_height_density)
pd(mod_height_density)

brms::pp_check(mod_height_density)
mod_check_height_density <- createDHARMa(
  simulatedResponse = t(posterior_predict(mod_height_density)),
  observedResponse = props$mean_height_prop,
  fittedPredictedResponse = apply(t(posterior_epred(mod_height_density)), 1, mean),
  integerResponse = TRUE)
plot(mod_check_height_density)

mod_height_treatment <- brm(mean_height_prop ~ scale_cont_treatment * 
                              scale_log_grunt_pee_m2 +
                              scale_distance +
                              scale_height_offset + 
                              scale_seagrass_area + 
                              (1|patch), 
                            seed = 123,
                            control = list(adapt_delta = 0.9), 
                            prior = main_priors,
                            family = Gamma(link = 'log'),
                            data = props)
#saveRDS(mod_height_treatment, "Data/main_model_height_treatment.rds")
mod_height_treatment <- readRDS("Data/main_model_height_treatment.rds")
summary(mod_height_treatment)
pd(mod_height_treatment)
#check fit
brms::pp_check(mod_height_treatment)
mod_check_height_treatment <- createDHARMa(
  simulatedResponse = t(posterior_predict(mod_height_treatment)),
  observedResponse = props$mean_height_prop,
  fittedPredictedResponse = apply(t(posterior_epred(mod_height_treatment)), 1, mean),
  integerResponse = TRUE)
plot(mod_check_height_treatment)

#shoots
mod_shoot_density <- brm(mean_shoot_prop ~ scale_log_cukes_final * 
                           scale_log_grunt_pee_m2 +
                           scale_distance +
                           scale_seagrass_area + 
                           scale_shoot_offset +
                           (1|patch), 
                         seed = 123,
                         control = list(adapt_delta = 0.9), 
                         family = Gamma(link = 'log'),
                         iter = 3000,
                         prior = main_priors,
                         data = props)
#saveRDS(mod_shoot_density, "Data/main_model_shoot_density.rds")
mod_shoot_density <- readRDS("Data/main_model_shoot_density.rds")
summary(mod_shoot_density)
pd(mod_shoot_density)

brms::pp_check(mod_shoot_density)
mod_check_shoot_density <- createDHARMa(
  simulatedResponse = t(posterior_predict(mod_shoot_density)),
  observedResponse = props$mean_shoot_prop,
  fittedPredictedResponse = apply(t(posterior_epred(mod_shoot_density)), 1, mean),
  integerResponse = TRUE)
plot(mod_check_shoot_density)

mod_shoot_treatment <- brm(mean_shoot_prop ~ scale_cont_treatment * 
                             scale_log_grunt_pee_m2 +
                             scale_distance +
                             scale_shoot_offset + 
                             scale_seagrass_area + 
                             (1|patch), 
                           seed = 123,
                           control = list(adapt_delta = 0.95), 
                           iter = 3000,
                           prior = main_priors,
                           family = Gamma(link = 'log'),
                           data = props)
#saveRDS(mod_shoot_treatment, "Data/main_model_shoot_treatment.rds")
mod_shoot_treatment <- readRDS("Data/main_model_shoot_treatment.rds")
summary(mod_shoot_treatment)
pd(mod_shoot_treatment)
#check fit
brms::pp_check(mod_shoot_treatment)
mod_check_shoot_treatment <- createDHARMa(
  simulatedResponse = t(posterior_predict(mod_shoot_treatment)),
  observedResponse = props$mean_shoot_prop,
  fittedPredictedResponse = apply(t(posterior_epred(mod_shoot_treatment)), 1, mean),
  integerResponse = TRUE)
plot(mod_check_shoot_treatment)

#above
mod_above_density <- brm(mean_above_prop ~ scale_log_cukes_final * 
                           scale_log_grunt_pee_m2 +
                           scale_distance +
                           scale_seagrass_area + 
                           scale_above_offset +
                           (1|patch), 
                         seed = 123,
                         control = list(adapt_delta = 0.9), 
                         family = Gamma(link = 'log'),
                         prior = main_priors,
                         iter = 3000,
                         data = props)
#saveRDS(mod_above_density, "Data/main_model_above_density.rds")
mod_above_density <- readRDS("Data/main_model_above_density.rds")
summary(mod_above_density)
pd(mod_above_density)

brms::pp_check(mod_above_density)
mod_check_above_density <- createDHARMa(
  simulatedResponse = t(posterior_predict(mod_above_density)),
  observedResponse = props$mean_above_prop,
  fittedPredictedResponse = apply(t(posterior_epred(mod_above_density)), 1, mean),
  integerResponse = TRUE)
plot(mod_check_above_density)

mod_above_treatment <- brm(mean_above_prop ~ scale_cont_treatment * 
                             scale_log_grunt_pee_m2 +
                             scale_distance +
                             scale_above_offset + 
                             scale_seagrass_area + 
                             (1|patch), 
                           seed = 123,
                           control = list(adapt_delta = 0.9), 
                           prior = main_priors,
                           family = Gamma(link = 'log'),
                           iter = 3000,
                           data = props)
#saveRDS(mod_above_treatment, "Data/main_model_above_treatment.rds")
mod_above_treatment <- readRDS("Data/main_model_above_treatment.rds")
summary(mod_above_treatment)
pd(mod_above_treatment)
#check fit
brms::pp_check(mod_above_treatment)
mod_check_above_treatment <- createDHARMa(
  simulatedResponse = t(posterior_predict(mod_above_treatment)),
  observedResponse = props$mean_above_prop,
  fittedPredictedResponse = apply(t(posterior_epred(mod_above_treatment)), 1, mean),
  integerResponse = TRUE)
plot(mod_check_above_treatment)

#below
mod_below_density <- brm(mean_below_prop ~ scale_log_cukes_final * 
                           scale_log_grunt_pee_m2 +
                           scale_distance +
                           scale_seagrass_area + 
                           scale_below_offset +
                           (1|patch), 
                         seed = 123,
                         control = list(adapt_delta = 0.93), 
                         family = Gamma(link = 'log'),
                         prior = main_priors,
                         iter = 3000,
                         data = props)
#saveRDS(mod_below_density, "Data/main_model_below_density.rds")
mod_below_density <- readRDS("Data/main_model_below_density.rds")
summary(mod_below_density)
pd(mod_below_density)

brms::pp_check(mod_below_density)
mod_check_below_density <- createDHARMa(
  simulatedResponse = t(posterior_predict(mod_below_density)),
  observedResponse = props$mean_below_prop,
  fittedPredictedResponse = apply(t(posterior_epred(mod_below_density)), 1, mean),
  integerResponse = TRUE)
plot(mod_check_below_density)

mod_below_treatment <- brm(mean_below_prop ~ scale_cont_treatment * 
                             scale_log_grunt_pee_m2 +
                             scale_distance +
                             scale_below_offset + 
                             scale_seagrass_area + 
                             (1|patch), 
                           seed = 123,
                           control = list(adapt_delta = 0.9), 
                           prior = main_priors,
                           iter = 3000,
                           family = Gamma(link = 'log'),
                           data = props)
#saveRDS(mod_below_treatment, "Data/main_model_below_treatment.rds")
mod_below_treatment <- readRDS("Data/main_model_below_treatment.rds")
summary(mod_below_treatment)
pd(mod_below_treatment)
#check fit
brms::pp_check(mod_below_treatment)
mod_check_below_treatment <- createDHARMa(
  simulatedResponse = t(posterior_predict(mod_below_treatment)),
  observedResponse = props$mean_below_prop,
  fittedPredictedResponse = apply(t(posterior_epred(mod_below_treatment)), 1, mean),
  integerResponse = TRUE)
plot(mod_check_below_treatment)
#looks fine


#PART THREE SUPPLEMENTAL: TEST LOG CONSTANT OPTIONS-------------------------
#we want to confirm that our results are robust to the choice of small value we
#added to the cuke density before we log it, so we'll try an extremely small 
#value and an extremely large value (relative to the range of non-zero values in
#our dataset) to check and see if the results change
growth_checks <- growths %>% 
  mutate(scale_large_cuke_log = scale(log(final_cuke_density + 0.015)),
         scale_small_cuke_log = scale(log(final_cuke_density + 0.0001)))

growth_priors <- prior_string("normal(0,1)", class = "b")

#original growth model
mod_growth_original <- readRDS("Data/final_growth_rate_model.rds")

#large value
mod_growth_large <- brm(blade_height ~ scale_distance + 
                          scale_large_cuke_log * 
                          scale_log_grunt_pee_m2 + 
                          scale_below_per_shoot +
                          scale_seagrass_area +
                          (1|patch/quadrat), 
                        family = Gamma(link = "log"),
                        data = growth_checks, 
                        iter = 3000,
                        #seed for reproducibility
                        seed = 1234,
                        #priors to provide slight regularization
                        prior = growth_priors,
                        #increase adapt delta to prevent divergent transitions
                        control = list(adapt_delta = 0.95))
#saveRDS(mod_growth_large, "Data/log_check_model_large.rds")
mod_growth_large <- readRDS("Data/log_check_model_large.rds")

#small value
mod_growth_small <- brm(blade_height ~ scale_distance + 
                          scale_small_cuke_log * 
                          scale_log_grunt_pee_m2 + 
                          scale_below_per_shoot +
                          scale_seagrass_area +
                          (1|patch/quadrat), 
                        family = Gamma(link = "log"),
                        data = growth_checks, 
                        iter = 3000,
                        #priors to provide slight regularization
                        prior = growth_priors,
                        #increase adapt delta to prevent divergent transitions
                        control = list(adapt_delta = 0.95))
#saveRDS(mod_growth_small, "Data/log_check_model_small.rds")
mod_growth_small <- readRDS("Data/log_check_model_small.rds")

summary(mod_growth_original)
summary(mod_growth_large)
summary(mod_growth_small)
pd(mod_growth_original)
pd(mod_growth_large)
pd(mod_growth_small)
#and it looks like our results are really robust to the choice of constant used!
#the qualitative results are identical in all cases and the effect sizes are 
#really similar

#PART THREE SUPPLEMENTAL: PRIORS-------------------------
#create three sets of priors on the effects and rerun the model for each
growth_priors_flat <- prior_string("normal(0,100)", class = "b")
growth_priors_strong <- prior_string("normal(0,0.1)", class = "b")

#use the original model for the weakly regularizing priors
#saveRDS(mod_growth, "Data/prior_check_model_weak.rds")
mod_growth_weak <- readRDS("Data/prior_check_model_weak.rds")

mod_growth_flat <- brm(blade_height ~ scale_distance + 
                     scale_log_grunt_pee_m2  *
                     scale_log_cuke_density_final +
                     scale_below_per_shoot +
                     scale_seagrass_area +
                     (1|patch/quadrat), 
                   family = Gamma(link = "log"),
                   data = growths, 
                   iter = 3000,
                   #completely flat priors
                   prior = growth_priors_flat,
                   #increase adapt delta to prevent divergent transitions
                   control = list(adapt_delta = 0.98))
#saveRDS(mod_growth_flat, "Data/prior_check_model_flat.rds")
mod_growth_flat <- readRDS("Data/prior_check_model_flat.rds")

mod_growth_strong <- brm(blade_height ~ scale_distance + 
                         scale_log_grunt_pee_m2  *
                         scale_log_cuke_density_final +
                         scale_below_per_shoot +
                         scale_seagrass_area +
                         (1|patch/quadrat), 
                       family = Gamma(link = "log"),
                       data = growths, 
                       iter = 3000,
                       #strongly informative priors
                       prior = growth_priors_strong,
                       #increase adapt delta to prevent divergent transitions
                       control = list(adapt_delta = 0.95))
#saveRDS(mod_growth_strong, "Data/prior_check_model_strong.rds")
mod_growth_strong <- readRDS("Data/prior_check_model_strong.rds")

summary(mod_growth_flat)
summary(mod_growth_weak)
summary(mod_growth_strong)
pd(mod_growth_flat)
pd(mod_growth_weak)
pd(mod_growth_strong)

#and our results are robust to the prior choice as well! We can see that 
#normal(0,1) is functionally really similar to a flat prior in this case, which
#is unsurprising considering our effect sizes are so small (because we're 
#working in log-link space)